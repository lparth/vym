// vim: ts=2:sw=2:syn=javascript:fdm=syntax

// vym selftest script

vym.clearConsole();


var tests_total  = 0;
var tests_passed = 0;
var tests_failed = 0;

var vymBaseDir = vym.vymBaseDir();

var testDir = vymBaseDir + "/selftests";
var currentMapPath = "undefined."
var testMapDefault = vymBaseDir + "/test/maps/test-default.vym";
var testMapFrames  = vymBaseDir + "/test/maps/test-frames.vym";

const  center_0_string = "mc:0";
const  main_A_string = "mc:0,bo:0";
const    branch_0Aa_string = main_A_string + ",bo:0";
const    branch_0Ab_string = main_A_string + ",bo:1";
const    branch_0Ac_string = main_A_string + ",bo:2";
const  main_B_string="mc:0,bo:1";
const    branch_0Ba_string = main_B_string + ",bo:0";
const    branch_0Bb_string = main_B_string + ",bo:1";
const  center_1_string = "mc:1";
const  center_2_string = "mc:2";
const  center_3_string = "mc:3";


// Compare and log values
function expect(comment, v_real, v_expected) {
	tests_total = tests_total +1;
    if (v_real == v_expected) {
        vym.print ("PASS: " + comment);
		tests_passed = tests_passed +1;
    } else {
        vym.print ("FAIL: '" + comment + "' - Expected \"" + v_expected + "\", but got \"" + v_real + "\"");
		tests_failed = tests_failed +1;
    throw "Test failed.";
    }
}

function expectInclude(comment, s, substring)
{
  if( s.includes(substring)) {
    vym.print("PASS: " + comment);
    tests_passed = tests_passed + 1;
    // waitkey
  } else {
    vym.print("FAIL: " + comment + ". Could not find \"" + substring + "\" in string below:");
    vym.print("\"" + s + "\"");
    tests_failed = tests_failed - 1;
    throw "Test failed.";
  }
  tests_total =tests_total + 1;
}

function expectNot(comment, v_real, v_expected) {
	tests_total = tests_total +1;
    if (v_real != v_expected) {
        vym.print("PASS: " + comment);
		tests_passed = tests_passed +1;
    } else {
        vym.print("FAIL: '" + comment + "' - Expected differemt values, but got " + v_expected + " and " + v_real);
		tests_failed = tests_failed +1;
    }
}


function initMap(mapPath)  // FIXME not fully ported yet: files parameter missing
{
  // Copy the map referenced above to @testDir/test-current.[vym|xml]
  // and try to load it
  if (mapPath.endsWith(".vym") )
      postfix = ".vym";
  else
      postfix = ".xml";

  if (!mapPath.startsWith("/") && mapPath[1] != ":") {
			// No absolute path, add vymBaseDir as prefix
	    mapPath = vymBaseDir + "/" + mapPath;
	}


  currentMapPath = testDir + "/maps/current-map" + postfix;

  if (vym.fileExists(currentMapPath)) {
      if (vym.fileRemove(currentMapPath))
				  vym.print("# Removed existing map: " + currentMapPath);
			else
				  vym.print("# Failed to remove existing map: " + currentMapPath);
  }

  // vym.print("# Copying " + mapPath + " to " + currentMapPath);
  vym.fileCopy(mapPath, currentMapPath);

    /*  Copy additional files, not yet implemented here
  files.each do |fn|
    begin
      FileUtils.cp fn, @testDir
      puts "# Copied #{fn} to #{@testDir}".light_black
    rescue
      puts "Failed to copy #{fn} to #{@testDir}".red
      exit
    end
  end
  */

  if (vym.loadMap(currentMapPath)) {
    let id = vym.currentMapID();
    vym.print("# Loaded " + currentMapPath + " (id: " + id + "  original: " + mapPath + ")");
    vym.gotoMap(id);

    map = vym.currentMap();
    b_main_A = map.findBranchById("{19840979-9f88-475c-8627-02e3066c8216}");

    return map;
  }

  throw "Failed to load \"" + mapPath + "\"";
}

function closeCurrentMap()
{
  id = vym.currentMapID();
  name = vym.currentMap().getFileName();
  if(vym.closeMapWithID(id)) {
    vym.print("# Closed map \"" + name + "\" (id: #{id})");
  } else {
    vym.print("# Failed to close map with id = #{id}. CurrentMapID = #{id}");
  }
}

function heading(h)
{
    vym.print("\n=== " + h + "===\n");
}

function summary()
{
  heading("Summary");
	vym.print ("Tests total: " + tests_total);
	vym.print ("Tests passed: " + tests_passed);
	vym.print ("Tests failed: " + tests_failed);
}

function test_vym()
{

  heading("Mainwindow checks:");
  version = "2.9.518"
  // FIXME expect_warning_only "Version is #{version}", @vym.version, version

  // FIXME expect "Temporary directory exists at '#{@testDir}'", File.exists?(@testDir), true


  map = initMap(testMapDefault);
  //expect ("init_map copies default testmap to '#{@currentMapPath}'", File.file?(@currentMapPath), true);
  //expect ("Title of copied map title is accessible and not empty", map.getMapTitle.length > 0, true);

  closeCurrentMap();
}

function test_basics()
{
  heading("Basic checks:");
  map = initMap(testMapDefault);
  title = "vym map used for testing";
  expect("map title is \"" + title +"\"", map.getTitle(), title);
  author ="Uwe Drechsel";
  expect("Author is \"" + author + "\"", map.getAuthor(), author);

  map.select(main_A_string);
  main_A = map.selectedBranch();
  expect ("select mainbranch A", map.getSelectionString(), main_A_string);
  expect ("headingText", main_A.headingText(), "Main A");
  expect ("branchCount", main_A.branchCount(), 3);

  main_A.selectLastBranch();
  b = map.selectedBranch();  
  expect("selectLastBranch", b.headingText(), "Main B");

  main_A.selectFirstBranch();
  b = map.selectedBranch();  
  expect("selectFirstBranch", b.headingText(), "Main A");

  b.selectParent();
  b = map.selectedBranch();  
  expect("selectParent", b.headingText(), "MapCenter 0");

  fdir = testDir + "/maps";
  dpath = fdir + "/current-map.vym";
  expect("getDestPath contains \"" + dpath + "\"", map.getDestPath().includes(dpath), true);
  expect("getFileDir contains \"" + fdir + "\"", map.getFileDir().includes(fdir), true);

  closeCurrentMap();
}

function test_adding_branches()
{
  heading("Adding branches:");
  map = initMap(testMapDefault);
  
  main_A = map.findBranchBySelection(main_A_string);
  n = main_A.branchCount();

  main_A.addBranch();
  expect("addBranch", main_A.branchCount(), n + 1 );

  map.selectLatestAdded();
  expect("selectLatestAdded", map.getSelectionString(), main_A_string + ",bo:3");

  b = map.selectedBranch()
  b.selectParent();
  expect("selectParent", map.getSelectionString(), main_A_string);

//  map.undo();
  map.undo();   // FIXME one undo() should be enough
                // caused by VM::applyDesign() adding one more
                // saveStates

  expect( "Undo: addBranch restores original branchCount", main_A.branchCount(), n );

  closeCurrentMap();

  map = initMap(testMapDefault);

  main_A = map.findBranchBySelection(main_A_string);
  n = main_A.branchCount();
  branch_0Aa = map.findBranchBySelection(branch_0Aa_string);
  main_A.addBranchAt( -3 );
  main_A.addBranchAt( -1 );
  expect("addBranchAbove/Below", main_A.branchCount(), n + 2);

  map.undo();
  map.undo();
  map.undo();
  map.undo();
  expect("Undo: addBranchAbove/Below", main_A.branchCount(), n);

  closeCurrentMap();

  map = initMap(testMapDefault);

  main_A = map.findBranchBySelection(main_A_string);
  branch_0Aa = map.findBranchBySelection(branch_0Aa_string);
  branch_0Aa.addBranchBefore();
  expect("addBranchBefore: check branchcount",  main_A.branchCount(), n);
  branch_0Aa.selectParent();
  b = map.selectedBranch();
  expectNot("addBranchBefore: heading is not 'Main A'", b.headingText(), "Main A");
  expectNot("addBranchBefore: heading is not 'branch a'", b.headingText(), "branch a");

  // Undo twice: addBranchNew and relinkTo
  map.undo();
  map.undo();
  expect("Undo: addBranchBefore", main_A.branchCount(), n);

  closeCurrentMap();
}

function test_adding_maps()
{
  heading("Adding maps");
  map = initMap(testMapDefault);
  main_A = map.findBranchBySelection(main_A_string);
  n = main_A.branchCount()

  branch_0Aa = map.findBranchBySelection(branch_0Aa_string);

  map.loadBranchReplace(currentMapPath, branch_0Aa);

  expect("loadBranchReplace: check branch count in '" + main_A.headingText() + "'", main_A.branchCount(), n + 1);

  branch_0Aa = map.findBranchBySelection(branch_0Aa_string);
  expect("loadBranchReplace: check if '" + branch_0Aa.headingText() + "' has 2 children", branch_0Aa.branchCount(), 2);
  expect("loadBranchReplace: check if '" + branch_0Aa.headingText() + "' is named 'MapCenter. 0'", branch_0Aa.headingText(), "MapCenter 0");

  branch_0Ab = map.findBranchBySelection(branch_0Ab_string);
  expect("loadBranchReplace: check if '" + branch_0Ab.headingText() + "' is named 'MapCenter. 1'", branch_0Ab.headingText(), "MapCenter 1");

  map.undo()
  // FIXME reassignment  should not be necessary
  main_A = map.findBranchBySelection(main_A_string);
  expect("Undo loadBranchReplace: check branch count in '" + main_A.headingText() + "'", main_A.branchCount(), n);
  // FIXME reassignment  should not be necessary
  branch_0Aa = map.findBranchBySelection(branch_0Aa_string);
  expect("Undo loadBranchReplace: check if '" + branch_0Aa.headingText() + "' has 2 children", branch_0Aa.branchCount(), 3);
  closeCurrentMap();

  map = initMap(testMapDefault);
  b = map.findBranchBySelection(branch_0Aa_string);
  n = b.branchCount();
  expect("loadBranchInsert '" + currentMapPath + "' returns true",
      b.loadBranchInsert(currentMapPath, 1),
      true);
  map.select(branch_0Aa_string);
  expect("loadBranchInsert: branch count of '" + b.headingText() + "' increased",  b.branchCount(), n + 2);

  b2 = map.findBranchBySelection(branch_0Aa_string + ",bo:1");
  expect("loadBranchInsert: new heading of branch_0Aa1 is 'MapCenter 0'", b2.headingText(), "MapCenter 0");
  b3 = map.findBranchBySelection(branch_0Aa_string + ",bo:2");
  expect("loadBranchInsert: new heading of branch_0Aa2 is 'MapCenter 1'", b3.headingText(), "MapCenter 1");

  map.undo();
  // FIXME reassignment  should not be necessary
  b = map.findBranchBySelection(branch_0Aa_string);
  expect("Undo: check branch count", b.branchCount(), 3);
  // FIXME reassignment  should not be necessary
  b = map.findBranchBySelection(branch_0Ab_string);
  expect("Undo: check heading",  b.headingText(), "branch b");
  closeCurrentMap();
}

function test_attributes()
{
  heading("Attributes:");
  
  map = initMap("test/maps/test-attributes.xml");

  map.select(main_A);
  b = map.selectedBranch();
  expect("String attribute is '6 * 9'", b.attributeAsString("string-attribute"), "6 * 9");
  expect("Integer attribute is 42", b.attributeAsInt("int-attribute"), 42);

  closeCurrentMap();
}

function test_copy_paste()
{
  heading("Copy and paste:");

  // Copy
  map = initMap(testMapDefault);
  
  main_A = map.findBranchBySelection(main_A_string);  
  main_A.select();

  n = main_A.branchCount();

  map.copy();
  map.paste();
  map.selectLatestAdded();     //FIXME-5 not set for ImportAdd, which is used by paste
  b = map.selectedBranch();
  s = map.getSelectionString();
  expect("Normal paste of branch, check heading of #{s}", b.headingText(), "Main A");

  map.undo()
  // FIXME reassignment  should not be necessary
  main_A = map.findBranchBySelection(main_A_string);  
  expect("Undo paste: branchCount of \"" + main_A.headingText() + "\"", main_A.branchCount(), n);

  map.redo()
  map.select(s);
  b = map.selectedBranch();  
  expect("redo paste: check heading", b.headingText(), "Main A");

  closeCurrentMap();

  // Multiple copy & paste
  map = initMap(testMapDefault);
  branch_0Ab = map.findBranchBySelection(branch_0Ab_string);
  branch_0Ab.select();
  map.copy();
  map.paste();

  branch_0Ac = map.findBranchBySelection(branch_0Ac_string);
  branch_0Ac.select();
  map.copy();
  map.paste();

  map.undo();
  map.undo();
  map.undo();
  map.undo();
  // FIXME reassignment  should not be necessary
  branch_0Ab = map.findBranchBySelection(branch_0Ab_string);
  branch_0Ac = map.findBranchBySelection(branch_0Ac_string);
  expect("Undo paste 4 times: \"" + branch_0Ab.headingText() + "\" has no children", branch_0Ab.branchCount(), 0);
  expect("Undo paste 4 times: \"" + branch_0Ac.headingText() + "\" has no children", branch_0Ac.branchCount(), 0);

  map.redo();
  map.redo();
  map.redo();
  map.redo();
  
  n = branch_0Ab.branchCount();
  expect("Redo paste 4 times: \"" + branch_0Ab.headingText() + "\" has child", n, 1);
  if (n == 1) {
    branch_0Ab.selectFirstChildBranch();
    b = map.selectedBranch();
    expect("Redo paste 4 times: 1st pasted branch has heading of parent", b.headingText(), b.parentBranch().headingText());
  }

  n = branch_0Ac.branchCount();
  expect("Redo paste 4 times: \"" + branch_0Ac.headingText() + "\" has child", n, 1);
  if (n == 1) {
    branch_0Ac.selectFirstChildBranch();
    b = map.selectedBranch();
    expect("Redo paste 4 times: 2nd pasted branch has heading of parent", b.headingText(), b.parentBranch().headingText());
  }

  closeCurrentMap();

  // Cut
  map = initMap(testMapDefault);

  main_A = map.findBranchBySelection(main_A_string);
  n = main_A.branchCount();
  map.select(branch_0Aa_string);
  map.cut();
  expect("cut: branchCount of \"" + main_A.headingText() + "\" decreased", main_A.branchCount(), n - 1);

  main_A.select();
  map.paste();
  main_A.selectLastChildBranch();
  pasted = map.selectedBranch();
  expect("Normal paste of branch, check heading of pasted branch", pasted.headingText(), "branch a");

  closeCurrentMap();
}
 
function test_delete_parts()
{
  heading("Deleting parts:");
  map = initMap(testMapDefault);
  
  main_A = map.findBranchBySelection(main_A_string);
  n = main_A.branchCount();
  branch_0Aa = map.findBranchBySelection(branch_0Aa_string);
  m = branch_0Aa.branchCount();
  h = branch_0Aa.headingText();  
  map.removeBranch(branch_0Aa);
  expect( "Remove branch: branchcount",  main_A.branchCount(), n - 1);
  map.undo();
  expect( "Undo Remove branch: branchcount parent", main_A.branchCount(), n);
  // FIXME reassignment  should not be necessary
  branch_0Aa = map.findBranchBySelection(branch_0Aa_string);
  expect( "Undo Remove branch: branchcount restored branch", branch_0Aa.branchCount(), m);
  expect( "Undo Remove branch: heading is restored to \"" + h + "\"", branch_0Aa.headingText(), h);

  closeCurrentMap();

  map = initMap(testMapDefault);
  branch_0Aa = map.findBranchBySelection(branch_0Aa_string);
  n = branch_0Aa.branchCount();

  branch_0Aa.removeChildrenBranches();
  expect( "removeChildren: branchcount", branch_0Aa.branchCount(), 0);
  map.undo();
  // FIXME reassignment  should not be necessary
  branch_0Aa = map.findBranchBySelection(branch_0Aa_string);
  expect( "Undo: removeChildren: branchcount", branch_0Aa.branchCount(), n);

  closeCurrentMap();

  map = initMap(testMapDefault);
  main_A = map.findBranchBySelection(main_A_string);
  n = main_A.branchCount();
  branch_0Aa = map.findBranchBySelection(branch_0Aa_string);
  map.removeKeepChildren(branch_0Aa);

  expect( "removeKeepChildren: branchcount changed", main_A.branchCount(), n + m - 1);
  map.undo()
  // FIXME reassignment  should not be necessary
  main_A = map.findBranchBySelection(main_A_string);
  expect( "Undo: removeKeepChildren: branchcount of parent", main_A.branchCount(), n);
  // FIXME reassignment  should not be necessary
  branch_0Aa = map.findBranchBySelection(branch_0Aa_string);
  expect( "Undo: removeKeepChildren: branchcount of branch", branch_0Aa.branchCount(), m);

  closeCurrentMap();

  map = initMap(testMapDefault);

  n = map.centerCount();
  center_1 = map.findBranchBySelection(center_1_string);
     
  x = center_1.getPosX();
  y = center_1.getPosY();

  map.removeBranch(center_1);

  expect("remove mapCenter: number of centers decreased", map.centerCount(), n - 1);
  map.undo();

  // FIXME reassignment  should not be necessary
  center_1 = map.findBranchBySelection(center_1_string);
  expect("Undo remove mapCenter: number of centers increased", map.centerCount(), n);
  expect("Undo remove mapCenter: x position is unchanged", center_1.getPosX(), x);
  expect("Undo remove mapCenter: y position is unchanged", center_1.getPosY(), y);

  closeCurrentMap();
}

function test_export()
{
  heading("Export:");
  let map = initMap(testMapDefault);

  //HTML
  let exportdir = testDir + "/export-html";
  vym.mkdir(exportdir);
  let htmlpath = exportdir + "/output.html";
  let flagdir  = exportdir + "/flags";
  let pngpath = exportdir + "/output.png";
  let csspath = exportdir + "/vym.css";
  map.exportMap(["HTML", htmlpath, exportdir]);
  expect("exportHTML: HTML file exists", vym.fileExists(htmlpath), true);
  expect("exportHTML: HTML image exists", vym.fileExists(pngpath), true);
  expect("exportHTML: HTML flags dir exists", vym.directoryExists(flagdir), true);
  if (vym.directoryExists(flagdir))
    expect("exportHTML: HTML flags dir not empty", vym.directoryIsEmpty(flagdir), false);

  expect("exportHTML: HTML CSS exists", vym.fileExists(csspath), true);
  vym.fileExists(htmlpath);
  vym.removeDirectory(flagdir);
  vym.fileExists(pngpath);
  vym.fileExists(csspath);
  map.exportMap(["Last"]);
  expect("exportLast: HTML #{htmlpath} file exists", vym.fileExists(htmlpath), true);
  expect("exportLast: HTML image exists", vym.fileExists(pngpath), true);
  expect("exportHTML: HTML flags dir exists", vym.directoryExists(flagdir), true);
  if (vym.directoryExists(flagdir))
    expect("exportHTML: HTML flags dir not empty", vym.directoryIsEmpty(flagdir), false);

  expect("exportLast: HTML CSS exists", vym.fileExists(csspath), true);

  //AO
  exportdir = testDir + "/export-ao";
  vym.mkdir(exportdir);
  filepath = exportdir + "/output.txt";
  vym.print("filepath is " + filepath);
  map.exportMap(["AO", filepath]);
  expect("exportAO:    AO file exists", vym.fileExists(filepath), true);
  vym.removeFile(filepath);
  map.exportMap("Last");
  expect("exportLast:  AO file exists", vym.fileExists(filepath), true);

  //ASCII
  exportdir = testDir + "/export-ascii";
  Dir.mkdir(exportdir);
  filepath = exportdir + "/output.txt";
  map.exportMap("ASCII", filepath, false);
  expect("exportASCII: ASCII file exists", vym.fileExists(filepath), true);
  vym.removeFile(filepath);
  map.exportMap(["Last"]);
  expect("exportLast:  ASCII file exists", vym.fileExists(filepath), true);

  //CSV
  exportdir = testDir + "/export-csv";
  Dir.mkdir(exportdir);
  filepath = exportdir + "/output.csv";
  map.exportMap(["CSV", filepath]);
  expect("exportCSV:    CSV file exists", vym.fileExists(filepath), true);
  vym.removeFile(filepath);
  map.exportMap(["Last"]);
  expect("exportLast:  CSV file exists", vym.fileExists(filepath), true);

  //Image
  exportdir = testDir + "/export-image";
  Dir.mkdir(exportdir);
  filepath = exportdir + "/output.png";
  map.exportMap(["Image", filepath,"PNG"]);
  expect("exportImage: PNG file exists", vym.fileExists(filepath), true);
  vym.removeFile(filepath);
  map.exportMap(["Last"]);
  expect("exportLast:  PNG file exists", vym.fileExists(filepath), true);

  //LaTeX
  exportdir = testDir + "/export-latex";
  Dir.mkdir(exportdir);
  filepath = exportdir + "/output.tex";
  map.exportMap(["LaTeX", filepath]);
  expect("exportLaTeX:  LaTeX file exists", vym.fileExists(filepath), true);
  vym.removeFile(filepath);
  map.exportMap(["Last"]);
  expect("exportLast:   LaTeX file exists", vym.fileExists(filepath), true);

  //Markdown
  exportdir = testDiri + "/export-markdown";
  Dir.mkdir(exportdir);
  filepath = exportdir + "/output.md";
  map.exportMap("Markdown", filepath);
  expect("exportMarkdown:  Markdown file exists", vym.fileExists(filepath), true);
  vym.removeFile(filepath);
  map.exportMap(["Last"]);
  expect("exportLast:     Markdown file exists", vym.fileExists(filepath), true);

  //OrgMode
  exportdir = testDir + "/export-orgmode"
  Dir.mkdir(exportdir);
  filepath = exportdir + "/output.org";
  map.exportMap(["OrgMode", filepath]);
  expect("exportOrgMode:  OrgMode file exists", vym.fileExists(filepath), true);
  vym.removeFile(filepath);
  map.exportMap(["Last"]);
  expect("exportLast:     OrgMode file exists", vym.fileExists(filepath), true);

  //PDF
  exportdir = testDir + "/export-pdf";
  Dir.mkdir(exportdir);
  filepath = exportdir + "/output.pdf";
  map.exportMap(["PDF", filepath]);
  expect("exportPDF:  PDF file exists", vym.fileExists(filepath), true);
  vym.removeFile(filepath);
  map.exportMap(["Last"]);
  expect("exportLast: PDF file exists", vym.fileExists(filepath), true);

  //SVG
  exportdir = testDir + "/export-svg";
  Dir.mkdir(exportdir);
  filepath = exportdir + "/output.svg";
  map.exportMap(["SVG", filepath]);
  expect("exportSVG:  SVG file exists", vym.fileExists(filepath), true);
  vym.removeFile(filepath);
  map.exportMap(["Last"]);
  expect("exportLast: SVG file exists", vym.fileExists(filepath), true);

  //XML
  exportdir = testDir  + "/export-xml";
  Dir.mkdir(exportdir);
  filepath = exportdir + "/output.xml";
  map.exportMap(["XML", filepath, testDir]);
  expect("exportXML: XML file exists", vym.fileExists(filepath), true);
  vym.removeFile(filepath);
  map.exportMap(["Last"]);
  expect("exportLast: XML file exists", vym.fileExists(filepath), true);

  //OpenOffice Impress //FIXME-5
  //Taskjuggler //FIXME-5

  closeCurrentMap();
}

function test_extrainfo()
{
  heading("Extra information");
  let map = initMap(testMapDefault);
  map.setAuthor("Fra Erasmas");
  expect("Set and get map author", map.getAuthor(), "Fra Erasmas");
  map.setComment("xy z");
  expect("Set and get map comment", map.getComment(), "xy z");
  map.setTitle("vym rules!");
  expect("Set and get map title", map.getTitle(), "vym rules!");

  closeCurrentMap();
}

function  test_frames()
{
  heading("Frames:");
  map = initMap(testMapFrames);

  map.select(center_0_string);
  center_0 = map.selectedBranch();
  expect("Mapcenter of " + center_0_string + " has no inner frame", center_0.getFrameType(true), "NoFrame");
  expect("Mapcenter of " + center_0_string + " has no outer frame", center_0.getFrameType(true), "NoFrame");

  map.select(center_1_string);
  center_1 = map.selectedBranch();
  expect("Mapcenter of " + center_1_string + " has no inner frame", center_1.getFrameType(true), "NoFrame");
  expectNot("Mapcenter of " + center_1_string + " has outer frame", center_1.getFrameType(false), "NoFrame");

  map.select(center_2_string);
  center_2 = map.selectedBranch();
  expectNot("Mapcenter of " + center_2_string + " has inner frame", center_2.getFrameType(true), "NoFrame");
  expect("Mapcenter of " + center_2_string + " has no outer frame", center_2.getFrameType(false), "NoFrame");

  map.select(center_3_string);
  center_3 = map.selectedBranch();
  expectNot("Mapcenter of " + center_3_string + " has inner frame", center_3.getFrameType(true), "NoFrame");
  expectNot("Mapcenter of " + center_3_string + " has outer frame", center_3.getFrameType(false), "NoFrame");


  // Test changing frame types
  frameTypes = ["Rectangle", "RoundedRectangle", "Ellipse", "Circle", "Cloud"];
  for (ft of frameTypes) {
      center_0.setFrameType(true, ft);
      expect("Type changed to '" + ft + "'", center_0.getFrameType(true), ft);
  }

  i = center_0.getFramePenWidth(true);  
  center_0.setFramePenWidth(true, 10);  
  expect("Pen width is 10", center_0.getFramePenWidth(true), 10);  
  map.undo();  
  expect("Undo setFramePenWidth", center_0.getFramePenWidth(true), i);  

  i = center_0.getFramePadding(true);  
  center_0.setFramePadding(true, 20);  
  expect("Padding is 20", center_0.getFramePadding(true), 20);  
  map.undo();  
  expect("Undo setFramePadding", center_0.getFramePadding(true), i);  

  closeCurrentMap();
}

function test_history()
{
  heading("History");

  map = initMap(testMapDefault);

  map.select(main_A);
  let b = map.selectedBranch();
  map.setHeadingPlainText("A");
  map.setHeadingPlainText("B");
  map.setHeadingPlainText("C");
  map.undo();
  map.undo();
  map.undo();
  expect("Undo 3 times, after changing heading -> 'A' -> 'B' -> 'C'", b.headingText(), "Main A");
  map.redo();
  expect("Redo once", map.getHeadingPlainText(), "A");
  map.copy();
  map.redo();
  expect("Redo once more", map.getHeadingPlainText(), "B");
  map.redo();
  expect("Redo yet again", map.getHeadingPlainText(), "C");
  map.setHeadingPlainText("Main A");
  map.paste();
  map.selectLastChildBranch()
  expect("Paste from the past", map.getHeadingPlainText(), "A");
  map.remove();

  closeCurrentMap();
}

function test_load_legacy_maps()
{
  heading("Load legacy maps");

  let map = initMap("test/maps/legacy/legacy-text-2.4.0.xml");
  b = map.findBranchBySelection(branch_0Aa_string);
  expect("Heading with plaintext as characters is read", b.getHeading(), "Heading in characters");

  b = map.findBranchBySelection(center_0_string);
  expect("Checking parsing 'absPos': x-position of " + center_0_string + " is ok", b.getPosX(), 314);
  expect("Checking parsing 'absPos': y-position of " + center_0_string+ " is ok", b.getPosY(), 0);

  b = map.findBranchBySelection(main_A_string);

  // FIXME-2 Review setting relative positions from legacy maps,
  // probable there is an offset meanwhile
  //expect("Checking parsing 'relPos': x-position of " + main_A_string + " is ok", b.getPosX(), 123);
  //expect("Checking parsing 'relPos': y-position of " + main_A_string + " is ok", b.getPosY(), 42);

  closeCurrentMap();

  map = initMap("test/maps/legacy/time-management-1.13.33.vym");
  b = map.findBranchBySelection(main_A_string);
  let s = "To see an explanation";
  expect("<heading> using characters: Heading includes '#{s}'", b.getHeading().includes(s), true);
  expect("<vymnote> using <html>: creates RichText note", b.hasRichTextNote(), true);
  s = "time management";
  expect("<vymnote> using <html>: Note contains '#{s}'", b.getNoteText().includes(s), true);

  closeCurrentMap();

  map = initMap("test/maps/legacy/lifeforms-2.1.11.vym");

  s = "Life forms";
  b = map.findBranchBySelection(center_0_string);
  expect("<heading> using characters and HTML: includes '#{s}'", b.getHeadingXML().includes(s), true);
  s = "textMode=\"richText";
  expect("<heading> using characters creates RichText", b.getHeadingXML().includes(s), true);

  closeCurrentMap();

  map = initMap("test/maps/legacy/faq-2.5.21.xml");
  b = map.findBranchBySelection(branch_0Ab_string);

  s = "libqt5-devel.rpm";
  expect("<vymnote> using characters and CDATA: has RichText note", b.hasRichTextNote(), true);
  expect("<vymnote> using characters and CDATA: includes '#{s}'", b.getNoteText().includes(s), true);
  expect("<vymnote> using characters and CDATA: has RichText note", b.hasRichTextNote(), true);

  b = map.findBranchBySelection(branch_0Ac_string);
  s = "textMode=\"richText";
  expect("<heading> using characters and CDATA: creates RichText", b.getHeadingXML().includes(s), true);
  s = "CDATA heading";
  expect("<heading> using characters and CDATA: includes \"" + s + "\"", b.getHeading().includes(s), true);

  closeCurrentMap();


  files = [
    vymBaseDir + "/test/maps/legacy/external-note-plaintext.txt",
    vymBaseDir + "/test/maps/legacy/external-note-richtext.html" ];

  for (i in files) {
    vym.fileCopy(files[i], testDir + "/maps/");
  }
  /* FIXME-2 Loading files not supported yet
  map = initMap("test/maps/legacy/notes.xml", files);
  */

  map = initMap("test/maps/legacy/notes.xml");

  b = map.findBranchBySelection(branch_0Aa_string);
  expect("<note> with plaintext in external file: text has type PlainText",
    b.hasRichTextNote(), false);
  expectInclude("<note> with plaintext in external file: text is read correctly",
    b.getNoteText(),
    "PlainText note in file");

  b = map.findBranchBySelection(branch_0Ab_string);
  expect("<note> with plaintext in characters: text has type PlainText",
    b.hasRichTextNote(), false);
  expectInclude( "<note> reads plaintext from characters",
    b.getNoteText(),
    "PlainText note in characters");

  b = map.findBranchBySelection(branch_0Ac_string);
  expect("<note> with RichText in external file: text has type RichText",
    b.hasRichTextNote(), true);
  expectInclude( "<note> reads RichText from external file",
    b.getNoteText(),
    "RichText note in file");

  b = map.findBranchBySelection(branch_0Ba_string);
  expect("<htmlnote> with PlainText in characters: text has type PlainText",
    b.hasRichTextNote(), false);
  expectInclude( "<htmlnote> reads PlainText from characters",
    b.getNoteText(),
    "PlainText note in characters");

  b = map.findBranchBySelection(branch_0Bb_string);

  // Note: 1.4.0 maps might have a 2nd DTD preceding inline HTML
  // THis would be invalid XML and thus QXMLStreamReader cannot read
  // it. Workaround: Remove DTD manually
  expect("<htmlnote> with RichText in characters: text has type RichText",
    b.hasRichTextNote(), true);
  expectInclude( "<htmlnote> reads RichText from characters",
    b.getNoteText(),
    "RichText note in characters");

  closeCurrentMap();

  map = initMap("test/maps/legacy/xlinks.xml");
  // FIXME-5 add test: xlinks in subitems of branches (pre 1.13.2)
  b = map.findBranchBySelection(main_A_string);
  main_B = map.findBranchBySelection(main_B_string);
  expect("<xlink> within <branch> is read", b.xlinkCount(), 1);

  b.selectXLinkOtherEnd(0);
  other_end = map.selectedBranch();
  expect("<xlink> connects  '#{@main_A}' and '#{@main_B}'", other_end, main_B);
  closeCurrentMap();
}

function test_modify_branches()
{
  heading("Modifying branches");
  map = initMap(testMapDefault);

  b = map.findBranchBySelection(branch_0Aa_string);
  b.setHeadingText("Changed!");
  expect("setHeadingPlainText", b.headingText(), "Changed!");
  map.undo();
  expect("Undo: setHeadingPlainText", b.headingText(), "branch a");
  map.redo();
  expect("redo: setHeadingPlainText", b.headingText(), "Changed!");

  s = "<html><body style=\" font-family:'Noto Sans'; font-size:10pt; font-weight:400; font-style:normal;\">\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-family:'DejaVu Sans Mono'; font-size:24pt; font-weight:700; font-style:italic; color:#ffffff;\">Image</span></p></body></html>";

  b.setHeadingRichText(s);
  expect("Branch has RichText heading", b.hasRichTextHeading(), true);

  map.undo();
  expect("After undo branch no longer has RichText heading", b.hasRichTextHeading(), false);

  closeCurrentMap();

  // Sorting
  map = initMap(testMapDefault);
  main_A = map.findBranchBySelection(main_A_string);
  main_A.sortChildren(true);
  ha = "branch a";
  hc = "branch c";
  branch_0Aa = map.findBranchBySelection(branch_0Aa_string);
  branch_0Ac = map.findBranchBySelection(branch_0Ac_string);
  expect("After inverse sorting first child of \"Main A\" is \"" + hc + "\"", branch_0Aa.headingText(), hc);
  expect("After inverse sorting last child of \"Main A\" is \"" + ha + "\"", branch_0Ac.headingText(), ha);

  main_A.sortChildren();
  branch_0Aa = map.findBranchBySelection(branch_0Aa_string);
  branch_0Ac = map.findBranchBySelection(branch_0Ac_string);
  expect("After sorting first child of \"Main A\" is \"" + ha + "\"", branch_0Aa.headingText(), ha);
  expect("After sorting last child of \"Main A\" is \"" + hc + "\"", branch_0Ac.headingText(), hc);
  closeCurrentMap();

  // Undo inverse sorting
  map = initMap(testMapDefault);
  main_A = map.findBranchBySelection(main_A_string);
  main_A.sortChildren(true);
  map.undo();
  ha = "branch a";
  hc = "branch c";
  // FIXME reassignment  should not be necessary
  branch_0Aa = map.findBranchBySelection(branch_0Aa_string);
  branch_0Ac = map.findBranchBySelection(branch_0Ac_string);
  expect("After undo of inverse sorting first child of \"Main A\" is \"" + ha + "\"", branch_0Aa.headingText(), ha);
  expect("After undo of inverse sorting last child of \"Main A\" is \"" + hc + "\"", branch_0Ac.headingText(), hc);
  closeCurrentMap();
}

function test_modify_images()
{
  heading("Modifying images");
  let map = initMap(testMapDefault);

  b = map.findBranchBySelection(branch_0Aa_string);
  n = b.imageCount();

  success = b.loadImage(vymBaseDir + "/icons/vym.png");
  expect("loadImage() returns true for existing image", success, true);

  success = b.loadImage(vymBaseDir + "/foobar");
  expect("loadImage() returns false for not existing image", success, false);

  i = map.findImageBySelection(branch_0Aa_string + ",fi:0");
  h = i.headingText();  
  i.setHeadingText("Changed!");   
  expect("setHeadingPlainText", i.headingText(), "Changed!");
  map.undo();
  expect("Undo: setHeadingPlainText", i.headingText(), h);
  map.redo();
  expect("redo: setHeadingPlainText", i.headingText(), "Changed!");

  s = "<html><body style=\" font-family:'Noto Sans'; font-size:10pt; font-weight:400; font-style:normal;\">\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-family:'DejaVu Sans Mono'; font-size:24pt; font-weight:700; font-style:italic; color:#ffffff;\">Image</span></p></body></html>";

  i.setHeadingRichText(s);
  expect("Image has RichText heading", i.hasRichTextHeading(), true);

  map.undo();
  expect("After undo image no longer has RichText heading", i.hasRichTextHeading(), false);

  b = map.findBranchBySelection(branch_0Aa_string);
  n = b.imageCount();
  map.removeImage(i);  
  expect("After removing image, image count decreased", b.imageCount(), n - 1);  

  map.undo();  
  b = map.findBranchBySelection(branch_0Aa_string);
  n = b.imageCount();
  expect("Undo removing image, image count increased", b.imageCount(), n);  
  closeCurrentMap();
}

function test_moving_parts()
{
  heading("Moving parts");
  let map = initMap(testMapDefault);

  map.select(branch_0Aa_string);
  branch_0Aa  = map.selectedBranch();
  branch_0Aa.moveDown();
  expect("Moving down", branch_0Aa.getNum(), 1);
  map.undo();
  expect("Undo Moving down", branch_0Aa.getNum(), 0);

  map.select(branch_0Ab_string);
  branch_0Ab  = map.selectedBranch();
  branch_0Ab.moveUp();
  expect("Moving up", branch_0Ab.getNum(), 0);
  map.undo();
  expect("Undo moving up", branch_0Ab.getNum(), 1);

  map.select(main_B_string);
  main_B = map.selectedBranch();
  n = main_B.branchCount();
  branch_0Aa.relinkToBranch(main_B);
  expect("RelinkTo " + main_B.headingText() + ": branchCount increased there",  main_B.branchCount(), n + 1);

  map.undo();
  expect("Undo: RelinkTo " + main_B.headingText() + ": branchCount decreased there", main_B.branchCount(), n);

  // map.select(main_A_string);
  // main_A = map.selectedBranch();
  // err = map.relinkBranchTo(branch_0Aa,0,0,0);
  //FIXME-5 disabled, error not supported atm expect_error "RelinkTo myself fails.", err);

  n = branch_0Aa.branchCount();
  main_B.relinkToBranchAt(branch_0Aa, 1);
  expect("RelinkTo moves '" + main_B.headingText() + "' to '" + branch_0Aa.headingText() + "', pos 1: branchCount increased there",  branch_0Aa.branchCount(), n + 1);

  map.undo();
  map.select(center_0_string);
  center_0 = map.selectedBranch();  
  expect("Undo RelinkTo pos 1: branchCount of center", center_0.branchCount(), 2);

  closeCurrentMap();
}

function test_moving_parts()
{
  heading("Moving parts");
  let map = initMap(testMapDefault);

  map.select(branch_0Aa_string);
  branch_0Aa  = map.selectedBranch();
  branch_0Aa.moveDown();
  expect("Moving down", branch_0Aa.getNum(), 1);
  map.undo();
  expect("Undo Moving down", branch_0Aa.getNum(), 0);

  map.select(branch_0Ab_string);
  branch_0Ab  = map.selectedBranch();
  branch_0Ab.moveUp();
  expect("Moving up", branch_0Ab.getNum(), 0);
  map.undo();
  expect("Undo moving up", branch_0Ab.getNum(), 1);

  map.select(main_B_string);
  main_B = map.selectedBranch();
  n = main_B.branchCount();
  branch_0Aa.relinkToBranch(main_B);
  expect("RelinkTo " + main_B.headingText() + ": branchCount increased there",  main_B.branchCount(), n + 1);

  map.undo();
  expect("Undo: RelinkTo " + main_B.headingText() + ": branchCount decreased there", main_B.branchCount(), n);

  // map.select(main_A_string);
  // main_A = map.selectedBranch();
  // err = map.relinkBranchTo(branch_0Aa,0,0,0);
  //FIXME-5 disabled, error not supported atm expect_error "RelinkTo myself fails.", err);

  n = branch_0Aa.branchCount();
  main_B.relinkToBranchAt(branch_0Aa, 1);
  expect("RelinkTo moves '" + main_B.headingText() + "' to '" + branch_0Aa.headingText() + "', pos 1: branchCount increased there",  branch_0Aa.branchCount(), n + 1);

  map.undo();
  map.select(center_0_string);
  center_0 = map.selectedBranch();  
  expect("Undo RelinkTo pos 1: branchCount of center", center_0.branchCount(), 2);

  closeCurrentMap();
}

function test_notes()
{
  heading("Notes:");

  // Plaintext notes basic actions
  let map = initMap(testMapDefault);

  map.select(main_A);
  note_plain = "vymnote plaintext";
  map.setNotePlainText(note_plain);
  expect("Set note to \"#{note_plain}\". Still plaintext?", map.hasRichTextNote(), false);
  map.select(center_0);
  map.select(main_A);
  expect("After reselect, is note plaintext?", map.hasRichTextNote(), false);

  note_plain = "<b>plaintext, not bold!</b>"
  map.setNotePlainText(note_plain);
  expect("Set note to plaintext containing html tags. Still plaintext", map.hasRichTextNote(), false);
  note_new = map.getNoteText();
  map.select(center_0);
  map.select(main_A);
  expect("After reselect, is note text unchanged?", map.getNoteText(), note_new);
  expect("After reselect, is note plaintext?", map.hasRichTextNote(), false);

  // Plaintext notes copy & paste
  map.copy();
  map.paste();
  map.selectLastChildBranch();
  s = map.getSelectionString();
  expect("After copy& paste: New note unchanged?", map.getNoteText(), note_plain);
  expect("After copy& paste: New note Still plaintext?", map.hasRichTextNote(), false);
  map.remove();

  // Plaintext notes undo & redo
  map.select(main_A);
  map.setNotePlainText('Foobar');
  map.undo();
  expect("Undo after setNotePlainText restores previous note", map.getNoteText(), note_plain);
  map.redo();
  map.select(main_A);
  expect("Redo restores previous note", map.getNoteText(), 'Foobar');

  // Plaintext notes load & save
  note_org = vym.loadFile('notes/note-plain.txt');
  map.loadNote("test/notes/note-plain.txt");
  expect("Load plain text note from file. Still plaintext?", map.hasRichTextNote(), false);
  expect("Note contains 'not bold'", map.getNoteText().includes("not bold"), true);
  filepath = testDir + "/save-note.txt";
  map.saveNote(filepath);
  expect("Save note to file. Check if it contains 'textMode=\"plainText\"'", vym.loadFile(filepath).includes("textMode=\"plainText\""), true);
  expect("Save note to file. Check if it contains 'not bold'", vym.loadFile(filepath).includes("not bold"), true);
  expect("Save note to file. Check new format: no longer contains '<b>' element",vym.loadFile(filepath).includes("<b>"), false);
  expect("Save note to file. Check new format: no longer contains '<![CDATA['",vym.loadFile(filepath).includes("<![CDATA["), false);
  expect("Save note to file. Check new format: contains 'text=\"Plaintext'",vym.loadFile(filepath).includes("text=\"Plaintext"), true);

  // Delete note
  map.setNotePlainText("");
  expect("setNotePlainText(\"\") deletes note", map.hasNote(), false);

  closeCurrentMap();

  // RichText basic actions
  map = initMap(testMapDefault);
  rt_note = '<html><body style=" font-family:"Arial"; font-size:12pt; font-weight:400; font-style:normal;"> <p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:"DejaVu Sans Mono"; color:#000000;">Rich Text note with <b>not bold text</b></span></p></body></html>]]></vymnote>'
  b_main_A.setNoteRichText(rt_note);
  expect("b.setNoteRichText produces note", b_main_A.hasNote(), true);
  expect("b.setNoteRichText produces richText note", b_main_A.hasRichTextNote(), true);
  expect("After reselect, is note RichText?", b_main_A.hasRichTextNote(), true);


  // RichText notes copy & paste
  b_main_A.select();
  rt_note = map.getNoteXML();
  map.copy();
  map.paste();
  map.selectLastChildBranch();
  b = map.selectedBranch();
  expect("After copy & paste: New note still RichText?", b.hasRichTextNote(), true);
  expect("After copy & paste: New note unchanged?", b.getNoteXML(), rt_note);
  map.remove();

  // RichText notes undo & redo
  map.select(main_A);
  map.setNotePlainText('Foobar');
  map.undo();
  expect("Undo after setNotePlainText restores RichText note", map.getNoteXML(), rt_note);
  map.redo();
  map.select(main_A);
  expect("Redo restores previous plaintext note", map.getNoteText(), 'Foobar');

  // RichText notes load & save
  map.loadNote("test/notes/note.html");
  expect("Load HTML note from file and try to detect textMode. Is RichText?", map.hasRichTextNote(), true);
  filepath = testDir + "/save-note.txt";
  map.saveNote(filepath);
  expect("Save note to file. Check if it contains 'textMode=\"richText\"'", vym.loadFile(filepath).includes("textMode=\"richText\""), true);
  expect("Save note to file. Check if it contains 'bold'", vym.loadFile(filepath).includes("bold"), true);
  expect("Save note to file. Check new format: no longer contains '<b>' element", vym.loadFile(filepath).includes("<b>"), false);
  expect("Save note to file. Check new format: no longer contains '<![CDATA['", vym.loadFile(filepath).includes("<![CDATA["), false);
  expect("Save note to file. Check new format: contains 'text=\"&lt;'", vym.loadFile(filepath).includes("text=\"&lt;"), true);

  // Delete note
  map.setNotePlainText("");
  expect("setNotePlainText(\"\") deletes note", map.hasNote(), false);

  // Compatibility with notes from version < 2.5.0  # FIXME-3 missing

  closeCurrentMap();
}

function test_references()
{
  heading("References");
  let map = initMap(testMapDefault);

  map.select(main_A_string);
  main_A = map.selectedBranch();
  url = "www.insilmaril.de";
  main_A.setUrl(url);
  expect("setUrl to '#{url}'", main_A.getUrl(), url);

  map.undo();
  expect("undo setUrl", main_A.getUrl(), "");
  map.redo();
  expect("redo setUrl", main_A.getUrl(), url);
  main_A.setUrl("");
  expect("setUrl: unset Url with empty string", main_A.getUrl(), "");

  // Try to link to myself using a relative path
  vl = "selftests/maps/current-map.vym";
  main_A.setVymLink(vl);
  s = main_A.getVymLink();
  expect("setVymLink returns absolute path", map.getFileDir() + "/" + vl, s);
  map.undo();
  expect("undo: setVymLink", main_A.getVymLink(), "");
  map.redo();
  expect("redo: setVymLink", main_A.getVymLink(), s);
  map.undo

  closeCurrentMap();
}

function test_saving()
{
  heading("Saving");
  let map = initMap(testMapDefault);

  // Save selection without overwriting original map);
  map.select(branch_0Aa);
  let mapName = "test-saveSelection.vyp";
  let fn = testDir + "/" + mapName;
  map.saveSelection(fn);
  expect(
      "Save selection: '" + branch_0Aa + "' to '" + fn + "'",
      vym.fileExists(fn),
      true);

  closeCurrentMap();

  map = initMap(mapName);
  map.select(center_0);
  expect(
      "Save selection: After loading of '" + mapName + "' '" + center_0 + "' is ok",
      map.getHeadingPlainText(),
      "branch a");
  map.select(main_A);
  expect(
      "Save selection: After loading of '" + mapName + "' '" + main_A + "'  is ok",
      map.getHeadingPlainText(),
      "branch a1");

  closeCurrentMap();
}

function test_scrolling()
{
  heading("Scrolling and unscrolling:");
  map = initMap(testMapDefault);
  
  map.select(main_A);
 
  let b = map.selectedBranch();
  map.toggleScroll();
  expect("toggleScroll", b.isScrolled(), true);
  map.undo()
  expect("undo toggleScroll", b.isScrolled(), false);
  b.scroll();
  expect("scroll", b.isScrolled(), true);
  b.unscroll();
  expect("unscroll", b.isScrolled(), false);

  b.scroll();
  map.select(branch_0Aa);
  map.scroll();
  map.select(main_A);
  map.unscrollChildren();
  map.select(branch_0Aa);
  expect("unscrollChildren", map.isScrolled(), false);
  map.undo();
  map.select(branch_0Aa);
  expect("undo unscrollChildren", map.isScrolled(), true);

  closeCurrentMap();
}

function test_slides()
{
  heading("Slides");
  let map = initMap("test/maps/test-slides.xml");

  map.select(main_A);
  expect("Successfully loaded map with slides", map.slideCount(), 3);

  closeCurrentMap()
}

function test_standard_flags()
{
  heading("Standard flags");
  let map = initMap(testMapDefault);
  b = map.findBranchBySelection(main_A_string);

  function set_flag (f, index, array)
  {
    b.setFlagByName(f);
    vym.print("# Setting flag: " + f + " of branch " << b.headingText());  
    expect("Flag set: '" + f +"'", b.hasActiveFlag(f), true);
  }

  function unset_flag (f, index, array)
  {
    b.unsetFlagByName(f);
    vym.print("# Unsetting flag: " + f + " of branch " << b.headingText());  
    expect("Flag unset: '" + f +"'", b.hasActiveFlag(f), false);
  }

  // Group standard-mark
  for (flag of [ "exclamationmark","questionmark"])
    set_flag(flag);

  // Group standard-status
  for( flag of [ "hook-green",
    "wip",
    "cross-red",
    "stopsign" ] )
    unset_flag(flag);	

  // Group standard-smiley
  smileys = [ "smiley-good",
      "smiley-sad",
      "smiley-omb" ];
  for (flag of smileys )
    set_flag(flag);

  // Group standard-arrow
  arrows = [ "arrow-up",
    "arrow-down",
    "2arrow-up",
    "2arrow-down" ];
  for (flag of arrows)
    set_flag(flag);

  // Group standard-thumb
  for (flag of [ "thumb-up", "thumb-down" ] )
    set_flag(flag);

  // Without group
  divflags = [ "clock",
    "phone",
    "lamp",
    "rose",
    "heart",
    "present",
    "flash",
    "info",

    "lifebelt" ];
  for (flag of divflags)  
    set_flag(flag);

  expect(
      "Heart flag is set",
      b.hasActiveFlag("heart"),
      true);
      
  for (flag of smileys )
    unset_flag(flag);

  expect(
      "Smiley flag is no longer set",
      b.hasActiveFlag("smiley"),
      false);
      
  b.clearFlags();

  expect("clearFlags cleared exclamationmark", b.hasActiveFlag( "exclamationmark" ), false);
  expect("clearFlags cleared smiley-good", b.hasActiveFlag( "smiley-good" ), false);


  // Toggling flags
  flags = ["stopsign", "lifebelt"]
  for (flag of flags) {
    b.toggleFlagByName(flag);
    expect("toggleFlag: flag '" + flag + "' activated", b.hasActiveFlag(flag), true);

    b.toggleFlagByName(flag);
    expect("toggleFlag: flag '" + flag + "' deactivated", b.hasActiveFlag(flag), false);
  }

  closeCurrentMap();
}


function test_user_flags()
{
  heading("User flags");
  let map = initMap("test/maps/test-userflag.vym");

  b = map.findBranchBySelection(branch_0Aa_string);
  flagName = "userflag-vym";
  expect("Has active flag '" + flagName + "'", b.hasActiveFlag(flagName), true);

  closeCurrentMap();
}


function test_tasks()
{
  heading("Tasks");
  let map = initMap("test/maps/test-tasks.xml");

  branch_0Aa = map.findBranchBySelection(branch_0Aa_string);
  ha = branch_0Aa.headingText();
  expect("After loading '" + ha + "' has no task", branch_0Aa.hasTask(), false);

  branch_0Ab = map.findBranchBySelection(branch_0Ab_string);
  hb = branch_0Ab.headingText();

  expect("After loading '" + hb + "' has task", branch_0Ab.hasTask(), true);
  expect("After loading '" + hb + "' task sleeps more than 1000 days",
	branch_0Ab.getTaskSleepDays() > 1000,
	true);

  branch_0Aa.toggleTask();
  expect("Toggle task of '" + ha + "'" , branch_0Aa.hasTask(), true);

  branch_0Aa.cycleTask();
  branch_0Aa.cycleTask();
  branch_0Aa.cycleTask();
  expect("After three cycles, task is 'Finished'", branch_0Aa.getTaskStatus(), "Finished");
  map.undo();
  map.undo();
  expect("After two undos, task is 'NotStarted'", branch_0Aa.getTaskStatus(), "NotStarted");

/* FIXME-2 Date functions used in ruby tests not available here yet
   See also https://doc.qt.io/qt-6/qjsengine.html#globalObject   ECMA-262 for Date, Math, String

  date_today = DateTime.now
  delta_days = 123
  date_later = date_today + delta_days
  date_later_iso = date_later.strftime("%Y-%m-%dT%H:%M:%S");

  // Input: number of days
  date_new = delta_days
  expect("Set task sleep to number of days '#{date_new}' accepts input", map.setTaskSleep(date_new),  true);
  expect("Set task sleep to number of days '#{date_new}' has correct sleep value '#{delta_days}' days", map.getTaskSleepDays(), delta_days);

  // Input: number of seconds
  date_new = "10s"
  expect("Set task sleep to number of seconds '#{date_new}' accepts input", map.setTaskSleep(date_new),  true);

  // Input: number of hours
  date_new = "10h"
  expect("Set task sleep to number of hours '#{date_new}' accepts input", map.setTaskSleep(date_new),  true);

  // Input: Date
  date_new = date_later.strftime("%Y-%m-%d");
  expect("Set task sleep to ISO Date '#{date_new}' accepts input", map.setTaskSleep(date_new), true);
  expect("Set task sleep to ISO Date '#{date_new}' has correct sleep value '#{delta_days}' days", map.getTaskSleepDays(), delta_days);

  date_new = date_later.strftime("%d.%m.");
  expect("Set task sleep to German short form '#{date_new}' accepts input '#{date_new}'", map.setTaskSleep(date_new), true);
  expect("Set task sleep to German short form '#{date_new}' has correct sleep value (days)", map.getTaskSleepDays(), delta_days);

  date_new = date_later.strftime("%d.%m.%Y");
  expect("Set task sleep to German long form '#{date_new}' accepts input '#{date_new}'", map.setTaskSleep(date_new), true);
  expect("Set task sleep to German long form '#{date_new}' has correct sleep value (days)", map.getTaskSleepDays(), delta_days);

  // Input: Invalid strings
  date_new = "invalidDate"
  expect("Set task sleep to '#{date_new}' should fail", map.setTaskSleep(date_new), false);

  date_new = date_later.strftime("%d %m.%Y");
  expect("Set task sleep to '#{date_new}' should fail", map.setTaskSleep(date_new), false);

  // DateTime
  date_new = date_later_iso
  expect("Set task sleep to ISO DateTime '#{date_new}' accepts input", map.setTaskSleep(date_new), true);
  expect("Set task sleep to ISO DateTime '#{date_new}' returns correct sleep value '#{date_later_iso}'", map.getTaskSleep, date_later_iso);

  // Time only
  date_later = date_today

  date_new = "12:34"
  date_later_iso = date_today.strftime("%Y-%m-%dT12:34:00");
  expect("Set task sleep to time '#{date_new}' accepts input", map.setTaskSleep(date_new), true);
  expect("Set task sleep to time '#{date_new}' returns correct sleep value '#{date_later_iso}'",);
    map.getTaskSleep, date_later_iso

  date_new = "2:4"
  date_later_iso = date_today.strftime("%Y-%m-%dT02:04:00");
  expect("Set task sleep to time '#{date_new}' accepts input", map.setTaskSleep(date_new), true);
  expect("Set task sleep to time '#{date_new}' returns correct sleep value '#{date_later_iso}'",);
    map.getTaskSleep, date_later_iso

  date_new = "03:05"
  date_later_iso = date_today.strftime("%Y-%m-%dT03:05:00");
  expect("Set task sleep to time '#{date_new}' accepts input", map.setTaskSleep(date_new), true);
  expect("Set task sleep to time '#{date_new}' returns correct sleep value '#{date_later_iso}'",);
    map.getTaskSleep, date_later_iso
    */

  closeCurrentMap();
}

function test_xlinks()
{
  heading("XLinks:");
  map = initMap(testMapDefault);

  main_A = map.findBranchBySelection(main_A_string);
  main_B = map.findBranchBySelection(main_B_string);
  n = main_A.xlinkCount()
  xl = main_A.addXLink(main_B, 2,"#ff0000","Qt::DashDotLine");
  expect("xlink count increased after creating xlink", main_A.xlinkCount(), n + 1);

  expect("Default color of XLink", xl.getColor(), "#ff0000");
  expect("Default width of XLink", xl.getWidth(), 2);
  expect("Default style of XLink", xl.getPenStyle(), "Qt::DashDotLine");
  expect("Default style of XLink begin", xl.getStyleBegin(), "HeadFull");
  expect("Default style of XLink end",   xl.getStyleEnd(), "HeadFull");
  /// Cont here

  xl.setWidth(3);
  expect("New width of XLink", xl.getWidth(), 3);
  map.undo();
  expect("Undo width of XLink", xl.getWidth(), 2);

  xl.setColor("#00ff00");
  expect("New color of XLink", xl.getColor(), "#00ff00");
  map.undo();
  expect("Undo color of XLink", xl.getColor(), "#ff0000");

  xl.setStyle("Qt::SolidLine");
  expect("New style of XLink", xl.getPenStyle(), "Qt::SolidLine");
  map.undo();
  expect("Undo style of XLink", xl.getPenStyle(), "Qt::DashDotLine");

  xl.setStyleBegin("None");
  expect("New style of XLink begin", xl.getStyleBegin(), "None");
  map.undo();
  expect("Undo style of XLink begin", xl.getStyleBegin(), "HeadFull");

  xl.setStyleEnd("None");
  expect("New style of XLink end", xl.getStyleEnd(), "None");
  map.undo();
  expect("Undo style of XLink end", xl.getStyleEnd(), "HeadFull");

  // FIXME reassignment  should not be necessary
  main_A = map.findBranchBySelection(main_A_string);
  main_B = map.findBranchBySelection(main_B_string);

  main_A.selectXLinkOtherEnd(0);
  expect(
      "xlink connects  '" + main_A.headingText() + "'' and '" + main_B.headingText() + "'",
      map.getSelectionString(),
      main_B_string);

  closeCurrentMap();
}


///////////////////////////////////////////////////////////////
//  Auto porting end
///////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////

// test_vym();  // FIXME currently not used (version check, tmpDir check)

    // ok, already using new Wrapper functions
test_basics();
test_adding_branches();
//test_adding_maps();
  //test_attributes();        // FIXME not ported yet
//test_copy_paste();
test_delete_parts();
  //test_export();            // FIXME WIP
//test_extrainfo();
//test_frames();
  //test_history();           // FIXME not ported yet
//test_load_legacy_maps();
//test_modify_branches();
test_modify_images();
//test_moving_parts();
  //test_notes();             // FIXME not ported yet
//test_references();
  //test_saving();            // FIXME not ported yet
  //test_scrolling();         // FIXME not ported yet
  //test_slides();            // FIXME not ported yet
//test_standard_flags();
//test_user_flags();
//test_tasks();	// FIXME-3 uncomplete (date calculations not ported yet from ruby)
//test_xlinks();

summary();
